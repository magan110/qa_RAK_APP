<!DOCTYPE html>
<html>
<head>
  <!-- Flutter build will replace this with the value from --base-href -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
  <meta name="description" content="RAK Web App" />

  <!-- PWA / theme -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="rak_web" />
  <meta name="theme-color" content="#ffffff" />
  <link rel="apple-touch-icon" href="icons/Icon-192.png" />

  <!-- Viewport -->
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover"
  />

  <!-- CSP (meta fallback). Prefer setting CSP as a response header in production. -->
  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self' https:;
          script-src 'self' https: 'unsafe-inline' 'unsafe-eval';
          img-src 'self' blob: data: https:;
          style-src 'self' 'unsafe-inline' https:;
          connect-src 'self' https: wss: blob: http://10.4.64.23:8521;
          font-src 'self' https:;
          media-src 'self' blob: data: https:;
          worker-src 'self' blob:;
          child-src 'self' blob:;
          frame-src 'self';
        " />

  <title>rak_web</title>
  <link rel="manifest" href="manifest.json" />

  <style>
    html, body { margin: 0; height: 100%; overscroll-behavior: none; background: #fff; }
  </style>
</head>
<body>
  <script src='https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.min.mjs' type='module'></script>
  <script type='module'>
  var { pdfjsLib } = globalThis;
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.mjs';

  var pdfRenderOptions = {
    cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/cmaps/',
    cMapPacked: true,
  }
  </script>
  <!-- (Optional) 3rd-party libs; self-host to simplify CSP -->
  <script defer src="https://unpkg.com/tesseract.js@4/dist/tesseract.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

  <!-- Your local scripts -->
  <script defer src="mlkit-ocr.js"></script>
  <script defer src="ocr.js"></script>

  <!-- Helpers exposed to Flutter (web) -->
  <script>
    // QR detection helper (expects ImageData RGBA buffer)
    window.detectQRCode = function(imageData, width, height) {
      try {
        if (typeof jsQR !== 'undefined') {
          const code = jsQR(imageData, width, height);
          return code ? code.data : null;
        }
      } catch (e) { console.error('QR detection error:', e); }
      return null;
    };

    // Geolocation helper â€” returns a Promise that resolves to { ok, lat, lng } or { ok:false, error }
    window.requestGeoPosition = async function () {
      if (!('geolocation' in navigator)) {
        return { ok: false, error: 'Geolocation not supported' };
      }
      return new Promise((resolve) => {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const lat = +pos.coords.latitude.toFixed(6);
            const lng = +pos.coords.longitude.toFixed(6);
            try {
              localStorage.setItem('lastLat', String(lat));
              localStorage.setItem('lastLng', String(lng));
            } catch (e) {}
            resolve({ ok: true, lat, lng });
          },
          (err) => resolve({ ok: false, error: err.message }),
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
        );
      });
    };
  </script>

  <!-- === Native Permissions Bridge for Flutter Web inside InAppWebView === -->
  <script>
    (function () {
      const w = window;
      const hasBridge = !!(w.flutter_inappwebview && typeof w.flutter_inappwebview.callHandler === 'function');

      async function callHandler(name, payload) {
        if (!hasBridge) {
          return { ok: false, status: 'no-bridge', error: 'InAppWebView bridge not available' };
        }
        try {
          const res = await w.flutter_inappwebview.callHandler(name, payload);
          return (res && typeof res === 'object') ? res : { ok: false, status: 'invalid', error: 'Bad response' };
        } catch (e) {
          return { ok: false, status: 'error', error: String(e) };
        }
      }

      // Warm up browser-side permission as well (so Web APIs work immediately)
      async function warmUpBrowser(type) {
        try {
          if (type === 'camera') {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return { ok: false, error: 'getUserMedia not supported' };
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(t => t.stop());
            return { ok: true };
          }
          if (type === 'microphone') {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return { ok: false, error: 'getUserMedia not supported' };
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(t => t.stop());
            return { ok: true };
          }
          if (type === 'geolocation') {
            return await w.requestGeoPosition();
          }
          if (type === 'notifications') {
            if (!('Notification' in w)) return { ok: false, error: 'Notifications not supported' };
            const perm = await Notification.requestPermission();
            return { ok: perm === 'granted', status: perm };
          }
          if (type === 'bluetooth') {
            // Web Bluetooth requires a user gesture; we just report capability here.
            if (!navigator.bluetooth) return { ok: false, error: 'Web Bluetooth not supported' };
            return { ok: true, status: 'user-gesture-required' };
          }
          // 'storage' has no direct prompt; you can attempt persistence if you want:
          if (type === 'storage' && navigator.storage && navigator.storage.persist) {
            const persisted = await navigator.storage.persist();
            return { ok: persisted, status: persisted ? 'persisted' : 'not-persisted' };
          }
          return { ok: true };
        } catch (e) {
          return { ok: false, error: String(e) };
        }
      }

      // Optional: query browser permission API where supported (best-effort)
      async function browserPermissionStatus(type) {
        try {
          if (!navigator.permissions || !navigator.permissions.query) return null;
          const nameMap = { camera: 'camera', microphone: 'microphone', geolocation: 'geolocation', notifications: 'notifications' };
          const name = nameMap[type];
          if (!name) return null;
          const status = await navigator.permissions.query({ name });
          return status.state; // 'granted' | 'prompt' | 'denied'
        } catch { return null; }
      }

      w.NativePerms = {
        /**
         * Request a native permission via InAppWebView + warm up browser API.
         * type: 'camera'|'microphone'|'geolocation'|'storage'|'notifications'|'bluetooth'
         * returns: { ok: boolean, status?: string, error?: string }
         */
        request: async function (type, rationale) {
          const native = await callHandler('perm_request', { type, rationale });
          // If native denied, surface that immediately
          if (!native.ok) return native;

          // Also warm-up browser side so Web APIs work right away
          const web = await warmUpBrowser(type);
          if (!web.ok) {
            // Still return native success but include web error for clarity
            return { ok: true, status: native.status || 'granted', webError: web.error || web.status };
          }
          return { ok: true, status: native.status || 'granted' };
        },

        /** Query native status (and attach browser status if available) */
        status: async function (type) {
          const native = await callHandler('perm_status', { type });
          const browser = await browserPermissionStatus(type);
          if (browser) native.browser = browser;
          return native;
        },

        /** Open app settings (native) */
        openSettings: function () {
          return callHandler('open_settings', {});
        }
      };
    })();
  </script>

  <!-- === Camera Uploader (open camera and upload as multipart/form-data) === -->
  <script>
    (function () {
      const w = window;

      // ---------- Hidden <input> path (primary) ----------
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      fileInput.capture = 'environment';
      fileInput.style.position = 'fixed';
      fileInput.style.left = '-9999px';
      document.body.appendChild(fileInput);

      function pickViaFileInput() {
        return new Promise((resolve, reject) => {
          fileInput.value = '';
          const onChange = () => {
            fileInput.removeEventListener('change', onChange);
            const f = fileInput.files && fileInput.files[0];
            if (!f) return reject(new Error('no-file-selected'));
            resolve(f);
          };
          fileInput.addEventListener('change', onChange, { once: true });
          // must be called from a user gesture
          fileInput.click();
        });
      }

      // ---------- getUserMedia() overlay fallback ----------
      function makeOverlay() {
        const wrap = document.createElement('div');
        wrap.style.cssText = `
          position:fixed; inset:0; background:rgba(0,0,0,0.85);
          display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:2147483647;
          color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
        `;
        const video = document.createElement('video');
        video.autoplay = true; video.playsInline = true; video.muted = true;
        video.style.cssText = 'max-width:90vw; max-height:60vh; background:#000; border-radius:12px;';
        const row = document.createElement('div');
        row.style.cssText = 'display:flex; gap:12px; margin-top:16px;';
        const btnShot = document.createElement('button');
        const btnCancel = document.createElement('button');
        [btnShot, btnCancel].forEach(b=>{
          b.style.cssText = 'padding:12px 18px; border-radius:10px; border:none; font-weight:600; cursor:pointer;';
        });
        btnShot.textContent = 'Take Photo';
        btnShot.style.background = '#21a0ff';
        btnCancel.textContent = 'Cancel';
        btnCancel.style.background = '#666';
        row.append(btnShot, btnCancel);
        const msg = document.createElement('div');
        msg.style.cssText = 'margin-top:10px; font-size:12px; opacity:.8;';
        msg.textContent = 'If video is black, camera permission was denied or not available.';
        wrap.append(video, row, msg);
        document.body.appendChild(wrap);
        return { wrap, video, btnShot, btnCancel };
      }

      async function pickViaGUM() {
        // iOS/Safari & desktop need HTTPS + user gesture
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('gum-not-supported');
        }
        const { wrap, video, btnShot, btnCancel } = makeOverlay();
        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: { ideal: 'environment' },
              width: { ideal: 1920 }, height: { ideal: 1080 }
            }
          });
        } catch (e) {
          wrap.remove();
          throw new Error('gum-permission-failed: ' + (e && e.message || e));
        }
        video.srcObject = stream;

        const file = await new Promise((resolve, reject) => {
          btnCancel.onclick = () => {
            try { stream.getTracks().forEach(t=>t.stop()); } catch {}
            wrap.remove(); reject(new Error('user-cancelled'));
          };
          btnShot.onclick = async () => {
            try {
              const canvas = document.createElement('canvas');
              const vw = video.videoWidth || 1920, vh = video.videoHeight || 1080;
              canvas.width = vw; canvas.height = vh;
              const ctx = canvas.getContext('2d', { alpha: false });
              ctx.drawImage(video, 0, 0, vw, vh);
              const blob = await new Promise(res=>canvas.toBlob(res, 'image/jpeg', 0.9));
              const f = new File([blob], 'camera.jpg', { type: 'image/jpeg' });
              resolve(f);
            } catch (e) { reject(e); }
            finally {
              try { stream.getTracks().forEach(t=>t.stop()); } catch {}
              wrap.remove();
            }
          };
        });
        return file;
      }

      async function downscale(file, maxW = 1600, q = 0.85) {
        try {
          const img = new Image();
          const url = URL.createObjectURL(file);
          await new Promise((ok, bad)=>{ img.onload=ok; img.onerror=bad; img.src=url; });
          const scale = Math.min(1, maxW / img.width);
          URL.revokeObjectURL(url);
          if (scale >= 1) return file;
          const c = document.createElement('canvas');
          c.width = Math.round(img.width * scale);
          c.height = Math.round(img.height * scale);
          c.getContext('2d', { alpha: false }).drawImage(img, 0, 0, c.width, c.height);
          const blob = await new Promise(res=>c.toBlob(res, 'image/jpeg', q));
          return new File([blob], file.name.replace(/\.\w+$/, '-scaled.jpg'), { type:'image/jpeg' });
        } catch { return file; }
      }

      async function fileToBase64(file) {
        return await new Promise((res, rej) => {
          const r = new FileReader();
          r.onload = () => res(String(r.result));
          r.onerror = rej;
          r.readAsDataURL(file);
        });
      }

      // Public API with multi-path fallback
      w.CameraUploader = {
        async pick({ prefer = 'input', downscaleImage = true } = {}) {
          try {
            if (w.NativePerms) await w.NativePerms.request('camera');

            let f;
            // try preferred path first, then fallback
            if (prefer === 'gum') {
              try { f = await pickViaGUM(); } catch (e) { f = await pickViaFileInput(); }
            } else {
              try { f = await pickViaFileInput(); } catch (e) { f = await pickViaGUM(); }
            }
            if (downscaleImage) f = await downscale(f);
            const base64 = await fileToBase64(f);
            return { ok: true, fileName: f.name, mime: f.type, size: f.size, base64 };
          } catch (e) {
            return { ok: false, error: String(e) };
          }
        },

        async upload({ endpoint, fieldName='photo', extra={}, headers={}, method='POST', prefer='input', downscaleImage=true } = {}) {
          if (!endpoint) return { ok:false, error:'Missing endpoint' };
          try {
            const picked = await this.pick({ prefer, downscaleImage });
            if (!picked.ok) return picked;

            // Convert base64 back to Blob/File (so servers get a real multipart file)
            const res = await fetch(picked.base64);
            let fileBlob = await res.blob();
            let file = new File([fileBlob], picked.fileName || 'photo.jpg', { type: picked.mime || 'image/jpeg' });

            const fd = new FormData();
            fd.append(fieldName, file, file.name);
            Object.entries(extra || {}).forEach(([k, v]) => fd.append(k, String(v)));

            const rsp = await fetch(endpoint, { method, body: fd, headers });
            const ct = rsp.headers.get('content-type') || '';
            const payload = ct.includes('application/json') ? await rsp.json().catch(()=>({})) : await rsp.text();
            return { ok: rsp.ok, status: rsp.status, data: payload };
          } catch (e) {
            return { ok:false, error:String(e) };
          }
        }
      };
    })();
  </script>

  <!-- Flutter bootstrap -->
  <script defer src="flutter_bootstrap.js"></script>
</body>
</html>
